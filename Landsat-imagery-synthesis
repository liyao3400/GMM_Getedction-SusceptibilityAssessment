/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var table = ee.FeatureCollection("users/YaoLiCD/HMA_Image_Coverage");
/***** End of imports. If edited, may not auto-convert in the playground. *****/

// Step 1: Define your Area of Interest (replace with your own FeatureCollection)
var roi = table;
var roi_geometry = roi.geometry();

// Step 2: Load Landsat-8 Surface Reflectance data
var l82015 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
  .filterBounds(roi_geometry)
  .filterDate('2015-1-01', '2015-11-30')
  .filter(ee.Filter.lt('CLOUD_COVER', 15))
  .select(['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'QA_PIXEL']);

// Step 3: Cloud and snow masking function
function maskCloudSnow(image) {
  var qa = image.select('QA_PIXEL');
  
  var cloudBitMask = 1 << 3;
  var snowBitMask  = 1 << 4;

  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
              .and(qa.bitwiseAnd(snowBitMask).eq(0));

  return image.updateMask(mask)
              .copyProperties(image, image.propertyNames());
}

// Step 4: Apply masking and select bands
var cleanCollection2015 = l82015.map(maskCloudSnow)
  .select(['SR_B2','SR_B3', 'SR_B4', 'SR_B5']);  // Blue, Green, Red, NIR

// Step 5: Create median composite (or use .mosaic() for most recent pixels)
var composite2015 = cleanCollection2015.median().clip(roi_geometry);  // Or use .mosaic()
composite2015 = composite2015.toInt16(); 


var l82020 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
  .filterBounds(roi_geometry)
  .filterDate('2021-1-01', '2021-11-30')
  .filter(ee.Filter.lt('CLOUD_COVER', 15))
  .select(['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'QA_PIXEL']);
var cleanCollection2020 = l82015.map(maskCloudSnow)
  .select(['SR_B2','SR_B3', 'SR_B4', 'SR_B5']);  // Blue, Green, Red, NIR

// Step 5: Create median composite (or use .mosaic() for most recent pixels)
var composite2020 = cleanCollection2020.median().clip(roi_geometry);  // Or use .mosaic()
composite2020 = composite2020.toInt16(); 

// ---- Calculate NDVI ----
var ndvi2015 = composite2015.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI_2015');
var ndvi_scaled2015 = ndvi2015.multiply(1000).int16();
var ndvi2020 = composite2020.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI_2020');
var ndvi_scaled2020 = ndvi2020.multiply(1000).int16();

// ---- NDVI Change ----
var ndviChange = ndvi_scaled2020.subtract(ndvi_scaled2020).rename('NDVI_Change');

var srtm = ee.Image('USGS/SRTMGL1_003');
// Clip DEM to ROI
var srtm_clip = srtm.clip(roi);
// Calculate slope (in degrees)
var slope = ee.Terrain.slope(srtm_clip).rename('slope');
// Calculate aspect (in degrees)
var aspect = ee.Terrain.aspect(srtm_clip).rename('aspect');

var stackedImage = ndvi_scaled2020
  .addBands(ndviChange)
  .addBands(aspect)
  .addBands(slope)
  .addBands(srtm_clip)
  .addBands(composite2020);
stackedImage=stackedImage.toInt16();
// Step 6: Visualization
Map.centerObject(roi, 8);
Map.addLayer(composite2020, {
  bands: ['SR_B2', 'SR_B3', 'SR_B4'],  // RGB
  min: 0,
  max: 30000
}, 'Minimal Cloud/Snow Composite');

stackedImage=stackedImage.toInt16();
// Step 7: Optional Export
Export.image.toDrive({
  image: stackedImage,
  description: 'L8_Clean_Composite',
  //bucket: 'your-gcs-bucket-name',             // ðŸ” Replace with your GCS bucket
  fileNamePrefix: 'landsat8_clean_composite_HMA',
  region: roi_geometry,
  scale: 30,
  crs: 'EPSG:4326',
  maxPixels: 1e13
});
